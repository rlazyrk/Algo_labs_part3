### Варіант 2

Для заданого бінарного дерева перевірте, чи воно є збалансованим деревом. Бінарне дерево вважається збалансованим, якщо різниця у висоті його лівого та правого піддерев не перевищує 1 для будь-якого піддерева.

Розглянемо таке бінарне дерево:
```
    1
   / \
  2   3
 / \     
4   5   
```

Це дерево є збалансованим, оскільки різниця висоти лівого піддерева та правого піддерева не перевищує 1.

Реалізована вами функція `is_tree_balanced(node: BinaryTree) -> bool` отримує на вхід корінь бінарного дерева та повертає `True`, якщо бінарне дерево є збалансованим, та `False`, якщо воно не збалансоване.

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

```
class BinaryTree:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```
